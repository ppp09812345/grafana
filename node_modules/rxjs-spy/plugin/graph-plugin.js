"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var plugin_1 = require("./plugin");
var graphRefSymbol = Symbol("graphRef");
function getGraphRef(ref) {
    return ref[graphRefSymbol];
}
exports.getGraphRef = getGraphRef;
function setGraphRef(ref, value) {
    ref[graphRefSymbol] = value;
    return value;
}
var GraphPlugin = (function (_super) {
    __extends(GraphPlugin, _super);
    function GraphPlugin(_a) {
        var _b = (_a === void 0 ? {} : _a).keptDuration, keptDuration = _b === void 0 ? 30000 : _b;
        var _this = _super.call(this, "graph") || this;
        _this.flushIntervalId_ = undefined;
        _this.flushQueue_ = [];
        _this.keptDuration_ = keptDuration;
        _this.notifications_ = [];
        _this.sentinel_ = {
            depth: 0,
            flattened: false,
            flattenings: [],
            flatteningsFlushed: 0,
            link: undefined,
            rootSink: undefined,
            sentinel: undefined,
            sink: undefined,
            sources: [],
            sourcesFlushed: 0
        };
        _this.sentinel_.link = _this.sentinel_;
        _this.sentinel_.sentinel = _this.sentinel_;
        return _this;
    }
    GraphPlugin.prototype.afterNext = function (ref, value) {
        var notifications_ = this.notifications_;
        notifications_.pop();
    };
    GraphPlugin.prototype.afterSubscribe = function (ref) {
        var notifications_ = this.notifications_;
        notifications_.pop();
    };
    GraphPlugin.prototype.afterUnsubscribe = function (ref) {
        var _a = this, notifications_ = _a.notifications_, sentinel_ = _a.sentinel_;
        notifications_.pop();
        this.flush_(ref);
    };
    GraphPlugin.prototype.beforeNext = function (ref, value) {
        var notifications_ = this.notifications_;
        notifications_.push({ notification: "next", ref: ref });
    };
    GraphPlugin.prototype.beforeSubscribe = function (ref) {
        var _a = this, notifications_ = _a.notifications_, sentinel_ = _a.sentinel_;
        var graphRef = setGraphRef(ref, {
            depth: 1,
            flattened: false,
            flattenings: [],
            flatteningsFlushed: 0,
            link: sentinel_,
            rootSink: undefined,
            sentinel: sentinel_,
            sink: undefined,
            sources: [],
            sourcesFlushed: 0
        });
        var length = notifications_.length;
        if ((length > 0) && (notifications_[length - 1].notification === "next")) {
            var sinkRef = notifications_[length - 1].ref;
            var sinkGraphRef = getGraphRef(sinkRef);
            sinkGraphRef.flattenings.push(ref);
            graphRef.link = sinkGraphRef;
            graphRef.flattened = true;
            graphRef.rootSink = sinkGraphRef.rootSink || sinkRef;
            graphRef.sink = sinkRef;
        }
        else {
            for (var n = length - 1; n > -1; --n) {
                if (notifications_[n].notification === "subscribe") {
                    var sinkRef = notifications_[length - 1].ref;
                    var sinkGraphRef = getGraphRef(sinkRef);
                    sinkGraphRef.sources.push(ref);
                    graphRef.depth = sinkGraphRef.depth + 1;
                    graphRef.link = sinkGraphRef;
                    graphRef.rootSink = sinkGraphRef.rootSink || sinkRef;
                    graphRef.sink = sinkRef;
                    break;
                }
            }
        }
        if (graphRef.link === graphRef.sentinel) {
            graphRef.sentinel.sources.push(ref);
        }
        notifications_.push({ notification: "subscribe", ref: ref });
    };
    GraphPlugin.prototype.beforeUnsubscribe = function (ref) {
        var notifications_ = this.notifications_;
        notifications_.push({ notification: "unsubscribe", ref: ref });
    };
    GraphPlugin.prototype.teardown = function () {
        if (this.flushIntervalId_ !== undefined) {
            clearInterval(this.flushIntervalId_);
            this.flushIntervalId_ = undefined;
        }
    };
    GraphPlugin.prototype.flush_ = function (ref) {
        var _this = this;
        var graphRef = getGraphRef(ref);
        var flattenings = graphRef.flattenings, sources = graphRef.sources;
        if (!ref.unsubscribed || !flattenings.every(function (ref) { return ref.unsubscribed; }) || !sources.every(function (ref) { return ref.unsubscribed; })) {
            return;
        }
        var keptDuration_ = this.keptDuration_;
        var link = graphRef.link, sink = graphRef.sink;
        var flush = function () {
            var flattenings = link.flattenings, sources = link.sources;
            var flatteningIndex = flattenings.indexOf(ref);
            if (flatteningIndex !== -1) {
                flattenings.splice(flatteningIndex, 1);
                ++link.flatteningsFlushed;
            }
            var sourceIndex = sources.indexOf(ref);
            if (sourceIndex !== -1) {
                sources.splice(sourceIndex, 1);
                ++link.sourcesFlushed;
            }
        };
        if (keptDuration_ === 0) {
            flush();
        }
        else if ((keptDuration_ > 0) && (keptDuration_ < Infinity)) {
            this.flushQueue_.push({ due: Date.now() + keptDuration_, flush: flush });
            if (this.flushIntervalId_ === undefined) {
                this.flushIntervalId_ = setInterval(function () {
                    var now = Date.now();
                    _this.flushQueue_ = _this.flushQueue_.filter(function (q) {
                        if (q.due > now) {
                            return true;
                        }
                        q.flush();
                        return false;
                    });
                    if (_this.flushQueue_.length === 0) {
                        clearInterval(_this.flushIntervalId_);
                        _this.flushIntervalId_ = undefined;
                    }
                }, keptDuration_);
            }
        }
    };
    return GraphPlugin;
}(plugin_1.BasePlugin));
exports.GraphPlugin = GraphPlugin;
