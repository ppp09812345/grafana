"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var auditor_1 = require("./auditor");
var detect_1 = require("./detect");
var detector_1 = require("./detector");
var hidden_1 = require("./hidden");
var identify_1 = require("./identify");
var logger_1 = require("./logger");
var match_1 = require("./match");
var operators_1 = require("./operators");
var plugin_1 = require("./plugin");
var spy_console_1 = require("./spy-console");
var util_1 = require("./util");
var observableSubscribe = rxjs_1.Observable.prototype.subscribe;
var previousWindow = {};
var SpyCore = (function () {
    function SpyCore(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.maxLogged_ = 20;
        if (SpyCore.spy_) {
            throw new Error("Already spying on Observable.prototype.subscribe.");
        }
        if (options.warning) {
            console.warn("Spying on Observable.prototype.subscribe.");
        }
        SpyCore.spy_ = this;
        rxjs_1.Observable.prototype.subscribe = SpyCore.coreSubscribe_;
        this.auditor_ = new auditor_1.Auditor(options.audit || 0);
        this.defaultLogger_ = options.defaultLogger || logger_1.defaultLogger;
        if (options.defaultPlugins === false) {
            this.plugins_ = [];
        }
        else {
            this.plugins_ = [
                new plugin_1.StackTracePlugin(options),
                new plugin_1.GraphPlugin(options),
                new plugin_1.SnapshotPlugin(this, options),
                new plugin_1.CyclePlugin(this, this.defaultLogger_),
                new plugin_1.StatsPlugin(this)
            ];
            if (options.devTools !== false) {
                this.plugins_.push(new plugin_1.DevToolsPlugin(this));
            }
        }
        this.pluginsSubject_ = new rxjs_1.BehaviorSubject(this.plugins_);
        this.tick_ = 0;
        this.undos_ = [];
        this.warned_ = {};
        var detector = new detector_1.Detector(this);
        detect_1.hook(function (id) { return _this.detect_(id, detector); });
        if (typeof window !== "undefined") {
            [options.global || "spy", "rxSpy"].forEach(function (key) {
                if (window.hasOwnProperty(key)) {
                    _this.defaultLogger_.log("Overwriting window." + key);
                    previousWindow[key] = window[key];
                }
                window[key] = spy_console_1.wrap(_this, key === "rxSpy" ?
                    function () { return _this.warnOnce(_this.defaultLogger_, "window." + key + " is deprecated and has been renamed; use window.spy instead"); } :
                    undefined);
            });
        }
        this.teardown_ = function () {
            if (typeof window !== "undefined") {
                [options.global || "spy", "rxSpy"].forEach(function (key) {
                    if (previousWindow.hasOwnProperty(key)) {
                        _this.defaultLogger_.log("Restoring window." + key);
                        window[key] = previousWindow[key];
                        delete previousWindow[key];
                    }
                    else {
                        delete window[key];
                    }
                });
            }
            detect_1.hook(undefined);
            _this.plugins_.forEach(function (plugin) { return plugin.teardown(); });
            _this.plugins_ = [];
            _this.pluginsSubject_.next(_this.plugins_);
            _this.undos_ = [];
            SpyCore.spy_ = undefined;
            rxjs_1.Observable.prototype.subscribe = observableSubscribe;
        };
    }
    Object.defineProperty(SpyCore.prototype, "auditor", {
        get: function () {
            return this.auditor_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpyCore.prototype, "tick", {
        get: function () {
            return this.tick_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpyCore.prototype, "undos", {
        get: function () {
            return this.undos_.slice();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpyCore.prototype, "version", {
        get: function () {
            return "7.5.1";
        },
        enumerable: true,
        configurable: true
    });
    SpyCore.prototype.debug = function (match) {
        var notifications = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            notifications[_i - 1] = arguments[_i];
        }
        if (notifications.length === 0) {
            notifications = ["complete", "error", "next", "subscribe", "unsubscribe"];
        }
        return this.plug(new plugin_1.DebugPlugin(match, notifications));
    };
    SpyCore.prototype.find = function (ctor) {
        var found = this.plugins_.find(function (plugin) { return plugin instanceof ctor; });
        return found ? found : undefined;
    };
    SpyCore.prototype.findAll = function (ctor) {
        return ctor ?
            this.plugins_.filter(function (plugin) { return plugin instanceof ctor; }) :
            this.plugins_;
    };
    SpyCore.prototype.flush = function () {
        this.plugins_.forEach(function (plugin) { return plugin.flush(); });
    };
    SpyCore.prototype.let = function (match, select, options) {
        return this.plug(new plugin_1.LetPlugin(match, select, options));
    };
    SpyCore.prototype.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var tagMatch = /.+/;
        var notificationMatch = /.+/;
        var predicate = function () { return true; };
        var partialLogger = this.defaultLogger_;
        if (args.length === 1) {
            var arg = args[0];
            if (typeof arg.log === "function") {
                partialLogger = arg;
            }
            else {
                tagMatch = arg;
            }
        }
        else if (args.length === 2) {
            var arg = void 0;
            tagMatch = args[0], arg = args[1];
            if (typeof arg.log === "function") {
                partialLogger = arg;
            }
            else {
                notificationMatch = arg;
            }
        }
        else if (args.length === 3) {
            tagMatch = args[0], notificationMatch = args[1], partialLogger = args[2];
        }
        return this.plug(new plugin_1.LogPlugin(this, tagMatch, notificationMatch, partialLogger));
    };
    SpyCore.prototype.maxLogged = function (value) {
        this.maxLogged_ = Math.max(value, 1);
    };
    SpyCore.prototype.pause = function (match) {
        var pausePlugin = new plugin_1.PausePlugin(match);
        var teardown = this.plug(pausePlugin);
        var deck = pausePlugin.deck;
        deck.teardown = teardown;
        return deck;
    };
    SpyCore.prototype.plug = function () {
        var _this = this;
        var plugins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            plugins[_i] = arguments[_i];
        }
        var _a, _b;
        (_a = this.plugins_).push.apply(_a, plugins);
        this.pluginsSubject_.next(this.plugins_);
        (_b = this.undos_).push.apply(_b, plugins);
        return function () { return _this.unplug.apply(_this, plugins); };
    };
    SpyCore.prototype.query = function (predicate, partialLogger) {
        var _this = this;
        var snapshotPlugin = this.find(plugin_1.SnapshotPlugin);
        if (!snapshotPlugin) {
            this.warnOnce(console, "Snapshotting is not enabled.");
            return;
        }
        var snapshot = snapshotPlugin.snapshotAll();
        var observableSnapshots = Array.from(snapshot.observables.values());
        var logger = logger_1.toLogger(partialLogger || this.defaultLogger_);
        snapshot.mapStackTraces(observableSnapshots).subscribe(function () {
            var found = [];
            observableSnapshots.forEach(function (observableSnapshot) {
                var find;
                var subscriptions = observableSnapshot.subscriptions;
                subscriptions.forEach(function (subscriptionSnapshot) {
                    var subscriberSnapshot = snapshot.subscribers.get(subscriptionSnapshot.subscriber);
                    if (subscriberSnapshot) {
                        if (predicate({
                            complete: subscriptionSnapshot.complete,
                            error: subscriptionSnapshot.error,
                            incomplete: !subscriptionSnapshot.complete && !subscriptionSnapshot.error,
                            path: observableSnapshot.path,
                            root: subscriptionSnapshot.sink === subscriptionSnapshot.rootSink,
                            tag: observableSnapshot.tag,
                            type: observableSnapshot.type,
                            unsubscribed: subscriptionSnapshot.unsubscribed
                        })) {
                            if (!find) {
                                find = {
                                    observable: observableSnapshot,
                                    subs: []
                                };
                            }
                            find.subs.push({
                                subscriber: subscriberSnapshot,
                                subscription: subscriptionSnapshot
                            });
                        }
                    }
                });
                if (find) {
                    found.push(find);
                }
            });
            var maxLogged_ = _this.maxLogged_;
            var notLogged = (found.length > maxLogged_) ? found.length - maxLogged_ : 0;
            if (notLogged) {
                found.splice(maxLogged_, notLogged);
            }
            logger.group(found.length + notLogged + " snapshot(s) found");
            var observableGroupMethod = (found.length > 3) ? "groupCollapsed" : "group";
            found.forEach(function (find) {
                var observableSnapshot = find.observable;
                logger[observableGroupMethod].call(logger, observableSnapshot.tag ?
                    "Tag = " + observableSnapshot.tag :
                    "Type = " + observableSnapshot.type);
                logger.log("Path =", observableSnapshot.path);
                var subs = find.subs;
                var subscriberGroupMethod = (find.subs.length > 3) ? "groupCollapsed" : "group";
                logger.group(subs.length + " subscriber(s)");
                subs.forEach(function (sub) {
                    var subscriptionSnapshot = sub.subscription;
                    var subscriberSnapshot = sub.subscriber;
                    var values = subscriberSnapshot.values, valuesFlushed = subscriberSnapshot.valuesFlushed;
                    logger[subscriberGroupMethod].call(logger, "Subscriber");
                    logger.log("Value count =", values.length + valuesFlushed);
                    if (values.length > 0) {
                        logger.log("Last value =", values[values.length - 1].value);
                    }
                    logSubscription(logger, subscriptionSnapshot);
                    var otherSubscriptions = Array
                        .from(subscriberSnapshot.subscriptions.values())
                        .filter(function (otherSubscriptionSnapshot) { return otherSubscriptionSnapshot !== subscriptionSnapshot; });
                    otherSubscriptions.forEach(function (otherSubscriptionSnapshot) {
                        logger.groupCollapsed("Other subscription");
                        logSubscription(logger, otherSubscriptionSnapshot);
                        logger.groupEnd();
                    });
                    logger.groupEnd();
                });
                logger.groupEnd();
                logger.groupEnd();
            });
            if (notLogged) {
                logger.log("... another " + notLogged + " snapshot(s) not logged.");
            }
            logger.groupEnd();
        });
    };
    SpyCore.prototype.show = function (match, partialLogger) {
        var anyTagged = /.+/;
        if (!match) {
            match = anyTagged;
        }
        else if (typeof match.log === "function") {
            partialLogger = match;
            match = anyTagged;
        }
        var snapshotPlugin = this.find(plugin_1.SnapshotPlugin);
        if (!snapshotPlugin) {
            this.warnOnce(console, "Snapshotting is not enabled.");
            return;
        }
        var snapshot = snapshotPlugin.snapshotAll();
        var matched = Array
            .from(snapshot.observables.values())
            .filter(function (observableSnapshot) { return match_1.matches(observableSnapshot.observable, match); });
        var logger = logger_1.toLogger(partialLogger || this.defaultLogger_);
        var maxLogged_ = this.maxLogged_;
        var notLogged = (matched.length > maxLogged_) ? matched.length - maxLogged_ : 0;
        if (notLogged) {
            matched.splice(maxLogged_, notLogged);
        }
        snapshot.mapStackTraces(matched).subscribe(function () {
            logger.group(matched.length + notLogged + " snapshot(s) matching " + match_1.toString(match));
            var observableGroupMethod = (matched.length > 3) ? "groupCollapsed" : "group";
            matched.forEach(function (observableSnapshot) {
                logger[observableGroupMethod].call(logger, observableSnapshot.tag ?
                    "Tag = " + observableSnapshot.tag :
                    "Type = " + observableSnapshot.type);
                logger.log("Path =", observableSnapshot.path);
                var subscriptions = observableSnapshot.subscriptions;
                var subscriberGroupMethod = (subscriptions.size > 3) ? "groupCollapsed" : "group";
                logger.group(subscriptions.size + " subscriber(s)");
                subscriptions.forEach(function (subscriptionSnapshot) {
                    var subscriberSnapshot = snapshot.subscribers.get(subscriptionSnapshot.subscriber);
                    if (subscriberSnapshot) {
                        var values = subscriberSnapshot.values, valuesFlushed = subscriberSnapshot.valuesFlushed;
                        logger[subscriberGroupMethod].call(logger, "Subscriber");
                        logger.log("Value count =", values.length + valuesFlushed);
                        if (values.length > 0) {
                            logger.log("Last value =", values[values.length - 1].value);
                        }
                        logSubscription(logger, subscriptionSnapshot);
                        var otherSubscriptions = Array
                            .from(subscriberSnapshot.subscriptions.values())
                            .filter(function (otherSubscriptionSnapshot) { return otherSubscriptionSnapshot !== subscriptionSnapshot; });
                        otherSubscriptions.forEach(function (otherSubscriptionSnapshot) {
                            logger.groupCollapsed("Other subscription");
                            logSubscription(logger, otherSubscriptionSnapshot);
                            logger.groupEnd();
                        });
                        logger.groupEnd();
                    }
                    else {
                        logger.warn("Cannot find subscriber snapshot");
                    }
                });
                logger.groupEnd();
                logger.groupEnd();
            });
            if (notLogged) {
                logger.log("... another " + notLogged + " snapshot(s) not logged.");
            }
            logger.groupEnd();
        });
    };
    SpyCore.prototype.stats = function (partialLogger) {
        var statsPlugin = this.find(plugin_1.StatsPlugin);
        if (!statsPlugin) {
            this.warnOnce(console, "Stats are not enabled.");
            return;
        }
        var stats = statsPlugin.stats;
        var leafSubscribes = stats.leafSubscribes, maxDepth = stats.maxDepth, flattenedSubscribes = stats.flattenedSubscribes, rootSubscribes = stats.rootSubscribes, totalDepth = stats.totalDepth;
        var logger = logger_1.toLogger(partialLogger || this.defaultLogger_);
        logger.group("Stats");
        logger.log("Subscribes =", stats.subscribes);
        if (rootSubscribes > 0) {
            logger.log("Root subscribes =", rootSubscribes);
        }
        if (leafSubscribes > 0) {
            logger.log("Leaf subscribes =", leafSubscribes);
        }
        if (flattenedSubscribes > 0) {
            logger.log("Flattened subscribes =", flattenedSubscribes);
        }
        logger.log("Unsubscribes =", stats.unsubscribes);
        logger.log("Nexts =", stats.nexts);
        logger.log("Errors =", stats.errors);
        logger.log("Completes =", stats.completes);
        if (maxDepth > 0) {
            logger.log("Max. depth =", maxDepth);
            logger.log("Avg. depth =", (totalDepth / leafSubscribes).toFixed(1));
        }
        logger.log("Tick =", stats.tick);
        logger.log("Timespan =", stats.timespan);
        logger.groupEnd();
    };
    SpyCore.prototype.teardown = function () {
        if (this.teardown_) {
            this.teardown_();
            this.teardown_ = undefined;
        }
    };
    SpyCore.prototype.unplug = function () {
        var _this = this;
        var plugins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            plugins[_i] = arguments[_i];
        }
        plugins.forEach(function (plugin) {
            plugin.teardown();
            _this.plugins_ = _this.plugins_.filter(function (p) { return p !== plugin; });
            _this.pluginsSubject_.next(_this.plugins_);
            _this.undos_ = _this.undos_.filter(function (u) { return u !== plugin; });
        });
    };
    SpyCore.prototype.warn = function (logger, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        this.warnOnce.apply(this, [logger, message].concat(args));
    };
    SpyCore.prototype.warnOnce = function (logger, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var _a;
        if (!this.warned_[message]) {
            (_a = logger_1.toLogger(logger)).warn.apply(_a, [message].concat(args));
            this.warned_[message] = true;
        }
    };
    SpyCore.coreSubscribe_ = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var observable = this;
        var spy_ = SpyCore.spy_;
        if (!spy_) {
            return observableSubscribe.apply(observable, args);
        }
        if (hidden_1.hidden(observable)) {
            SpyCore.spy_ = undefined;
            try {
                return observableSubscribe.apply(observable, args);
            }
            finally {
                SpyCore.spy_ = spy_;
            }
        }
        var notify_ = function (before, block, after) {
            ++spy_.tick_;
            spy_.plugins_.forEach(before);
            block();
            spy_.plugins_.forEach(after);
        };
        var subscriber = util_1.toSubscriber.apply(undefined, args);
        var ref = {
            observable: observable,
            subscriber: subscriber,
            subscription: new rxjs_1.Subscription(),
            timestamp: Date.now(),
            unsubscribed: false
        };
        identify_1.identify(observable);
        identify_1.identify(subscriber);
        identify_1.identify(ref);
        var subscriberUnsubscribe = subscriber.unsubscribe;
        subscriber.unsubscribe = function () {
            if (!subscriber.closed) {
                notify_(function (plugin) { return plugin.beforeUnsubscribe(ref); }, function () {
                    ref.subscription.unsubscribe();
                    ref.unsubscribed = true;
                    subscriberUnsubscribe.call(subscriber);
                }, function (plugin) { return plugin.afterUnsubscribe(ref); });
            }
            else {
                subscriberUnsubscribe.call(subscriber);
            }
        };
        var postSelectObserver = {
            complete: function () {
                notify_(function (plugin) { return plugin.beforeComplete(ref); }, function () { return subscriber.complete(); }, function (plugin) { return plugin.afterComplete(ref); });
            },
            error: function (error) {
                notify_(function (plugin) { return plugin.beforeError(ref, error); }, function () { return subscriber.error(error); }, function (plugin) { return plugin.afterError(ref, error); });
            },
            next: function (value) {
                notify_(function (plugin) { return plugin.beforeNext(ref, value); }, function () { return subscriber.next(value); }, function (plugin) { return plugin.afterNext(ref, value); });
            }
        };
        var preSelectObserver = {
            complete: function () {
                this.completed = true;
                if (this.preSelectSubject) {
                    this.preSelectSubject.complete();
                }
                else {
                    this.postSelectObserver.complete();
                }
            },
            completed: false,
            error: function (error) {
                this.errored = true;
                if (this.preSelectSubject) {
                    this.preSelectSubject.error(error);
                }
                else {
                    this.postSelectObserver.error(error);
                }
            },
            errored: false,
            let: function (plugins) {
                var selectors = plugins.map(function (plugin) { return plugin.select(ref); }).filter(Boolean);
                if (selectors.length > 0) {
                    if (!this.preSelectSubject) {
                        this.preSelectSubject = new rxjs_1.Subject();
                    }
                    if (this.postSelectSubscription) {
                        this.postSelectSubscription.unsubscribe();
                    }
                    var source_1 = this.preSelectSubject.asObservable();
                    selectors.forEach(function (selector) { return source_1 = selector(source_1); });
                    this.postSelectSubscription = source_1.pipe(operators_1.hide()).subscribe(postSelectObserver);
                }
                else if (this.postSelectSubscription) {
                    this.postSelectSubscription.unsubscribe();
                    this.postSelectSubscription = undefined;
                    this.preSelectSubject = undefined;
                }
            },
            next: function (value) {
                if (this.preSelectSubject) {
                    this.preSelectSubject.next(value);
                }
                else {
                    this.postSelectObserver.next(value);
                }
            },
            postSelectObserver: postSelectObserver,
            postSelectSubscription: undefined,
            preSelectSubject: undefined,
            unsubscribe: function () {
                if (!this.unsubscribed) {
                    this.unsubscribed = true;
                    if (!this.completed && !this.errored) {
                        if (this.postSelectSubscription) {
                            this.postSelectSubscription.unsubscribe();
                            this.postSelectSubscription = undefined;
                        }
                    }
                }
            },
            unsubscribed: false
        };
        subscriber.add(spy_.pluginsSubject_.pipe(operators_1.hide()).subscribe({
            next: function (plugins) { return preSelectObserver.let(plugins); }
        }));
        notify_(function (plugin) { return plugin.beforeSubscribe(ref); }, function () {
            subscriber.add(observableSubscribe.call(observable, preSelectObserver));
            subscriber.add(function () { return preSelectObserver.unsubscribe(); });
        }, function (plugin) { return plugin.afterSubscribe(ref); });
        return subscriber;
    };
    SpyCore.prototype.detect_ = function (id, detector) {
        var _a = this, auditor_ = _a.auditor_, defaultLogger_ = _a.defaultLogger_;
        auditor_.audit(id, function (ignored) {
            var detected = detector.detect(id);
            var logger = logger_1.toLogger(defaultLogger_);
            if (detected) {
                var audit = (ignored === 0) ? "" : "; ignored " + ignored;
                logger.group("Subscription changes detected; id = '" + id + "'" + audit);
                detected.subscriptions.forEach(function (s) {
                    logSubscription(logger, "Subscription", s);
                });
                detected.unsubscriptions.forEach(function (s) {
                    logSubscription(logger, "Unsubscription", s);
                });
                detected.flatteningSubscriptions.forEach(function (s) {
                    logSubscription(logger, "Flattening subscription", s);
                });
                detected.flatteningUnsubscriptions.forEach(function (s) {
                    logSubscription(logger, "Flattening unsubscription", s);
                });
                logger.groupEnd();
            }
            function logSubscription(logger, name, subscription) {
                logger.group(name);
                logger.log("Root subscribe", subscription.rootSink ?
                    subscription.rootSink.stackTrace :
                    subscription.stackTrace);
                logger.log("Subscribe", subscription.stackTrace);
                logger.groupEnd();
            }
        });
    };
    SpyCore.spy_ = undefined;
    return SpyCore;
}());
exports.SpyCore = SpyCore;
function logStackTrace(logger, subscriptionSnapshot) {
    var mappedStackTrace = subscriptionSnapshot.mappedStackTrace, rootSink = subscriptionSnapshot.rootSink;
    var mapped = rootSink ? rootSink.mappedStackTrace : mappedStackTrace;
    mapped.subscribe(function (stackTrace) { return logger.log("Root subscribe", stackTrace); });
}
function logSubscription(logger, subscriptionSnapshot) {
    var complete = subscriptionSnapshot.complete, error = subscriptionSnapshot.error, unsubscribed = subscriptionSnapshot.unsubscribed;
    logger.log("State =", complete ? "complete" : error ? "error" : "incomplete");
    if (error) {
        logger.error("Error =", error);
    }
    if (unsubscribed) {
        logger.log("Unsubscribed =", true);
    }
    logStackTrace(logger, subscriptionSnapshot);
}
